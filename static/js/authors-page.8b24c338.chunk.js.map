{"version":3,"sources":["components/BookPreview/BookPreview.js","components/BookList/BookList.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","pages/AuthorsPage/AuthorsPage.js"],"names":["BookPreview","imgUrl","title","className","src","alt","withRouter","books","location","map","id","to","pathname","state","from","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","AuthorsPage","authors","a","axios","get","response","this","setState","data","author","props","match","url","name","path","render","bookId","Number","params","authorId","authorBooks","find","BookList","Component"],"mappings":"qQAiBeA,EAbK,SAAC,GAAuB,IAArBC,EAAoB,EAApBA,OAAQC,EAAY,EAAZA,MAC7B,OACE,gCACE,qBAAKC,UAAU,oBAAf,SACE,qBAAKC,IAAKH,EAAQI,IAAKH,MAEzB,8BACE,6BAAKA,UCwBEI,G,MAAAA,aA3BE,SAAC,GAAyB,IAAvBC,EAAsB,EAAtBA,MAAOC,EAAe,EAAfA,SACzB,OACE,mCAGE,oBAAIL,UAAU,WAAd,SACGI,EAAME,KAAI,gBAAGC,EAAH,EAAGA,GAAIT,EAAP,EAAOA,OAAQC,EAAf,EAAeA,MAAf,OACT,6BAEE,cAAC,IAAD,CACES,GAAI,CACFC,SAAS,UAAD,OAAYF,GAGpBG,MAAO,CAAEC,KAAMN,IALnB,SAQE,cAAC,EAAD,CAAaP,OAAQA,EAAQC,MAAOA,OAV/BQ,e,gCCfJ,SAASK,EAAgBC,EAAKC,EAAKC,GAYhD,OAXID,KAAOD,EACTG,OAAOC,eAAeJ,EAAKC,EAAK,CAC9BC,MAAOA,EACPG,YAAY,EACZC,cAAc,EACdC,UAAU,IAGZP,EAAIC,GAAOC,EAGNF,ECVT,SAASQ,EAAQC,EAAQC,GACvB,IAAIC,EAAOR,OAAOQ,KAAKF,GAEvB,GAAIN,OAAOS,sBAAuB,CAChC,IAAIC,EAAUV,OAAOS,sBAAsBH,GACvCC,IAAgBG,EAAUA,EAAQC,QAAO,SAAUC,GACrD,OAAOZ,OAAOa,yBAAyBP,EAAQM,GAAKV,eAEtDM,EAAKM,KAAKC,MAAMP,EAAME,GAGxB,OAAOF,EAGM,SAASQ,EAAeC,GACrC,IAAK,IAAIC,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK,CACzC,IAAIG,EAAyB,MAAhBF,UAAUD,GAAaC,UAAUD,GAAK,GAE/CA,EAAI,EACNb,EAAQL,OAAOqB,IAAS,GAAMC,SAAQ,SAAUxB,GAC9C,EAAemB,EAAQnB,EAAKuB,EAAOvB,OAE5BE,OAAOuB,0BAChBvB,OAAOwB,iBAAiBP,EAAQjB,OAAOuB,0BAA0BF,IAEjEhB,EAAQL,OAAOqB,IAASC,SAAQ,SAAUxB,GACxCE,OAAOC,eAAegB,EAAQnB,EAAKE,OAAOa,yBAAyBQ,EAAQvB,OAKjF,OAAOmB,E,4OC8CMQ,E,4MAnEb/B,MAAQ,CACNgC,QAAS,I,8FAKX,4BAAAC,EAAA,sEACyBC,IAAMC,IAC3B,+CAFJ,OACQC,EADR,OAMEC,KAAKC,SAAS,CAAEN,QAASI,EAASG,OANpC,gD,0EASA,WAAU,IAAD,OACP,OACE,qCACE,6BACGF,KAAKrC,MAAMgC,QAAQpC,KAAI,SAAA4C,GAAM,OAC5B,6BAGE,cAAC,IAAD,CAAS1C,GAAE,UAAK,EAAK2C,MAAMC,MAAMC,IAAtB,YAA6BH,EAAO3C,IAA/C,SACG2C,EAAOI,QAJHJ,EAAO3C,SAWpB,cAAC,IAAD,CACEgD,KAAI,UAAKR,KAAKI,MAAMC,MAAMG,KAAtB,cAIJC,OAAQ,SAAAL,GAIN,IAAMM,EAASC,OAAOP,EAAMC,MAAMO,OAAOC,UAGnCC,EAAc,EAAKnD,MAAMgC,QAAQoB,MACrC,SAAAZ,GAAM,OAAIA,EAAO3C,KAAOkD,KAM1B,OACEI,GACE,qCACE,uGAAmBA,EAAYP,QAC/B,cAACS,EAAA,EAAD,2BAAcZ,GAAd,IAAqB/C,MAAOyD,EAAYzD,sB,GAvDhC4D","file":"static/js/authors-page.8b24c338.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nimport './BookPreview.scss';\r\n\r\nconst BookPreview = ({ imgUrl, title }) => {\r\n  return (\r\n    <div>\r\n      <div className=\"BookPreview-thumb\">\r\n        <img src={imgUrl} alt={title} />\r\n      </div>\r\n      <div>\r\n        <h5>{title}</h5>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default BookPreview;\r\n","import React from 'react';\r\n\r\nimport { Link, withRouter } from 'react-router-dom'; //Link - Для того чтобы при клике на книгу перенаправляло на новую страницу с информацией именно о ней; withRouter - компонент высшего порядка (грубо говор - это как композиция функций), который может оборачивать исходный компонент, и возвращать другой компонент. Если необходимо в каком-либо компоненте, который не рендерится Route, получить доступ к 3 props (match, history, location)\r\n\r\nimport BookPreview from '../BookPreview';\r\n\r\nimport './BookList.scss';\r\n\r\nconst BookList = ({ books, location }) => {\r\n  return (\r\n    <>\r\n      {/* <h1>This is BOOKS PAGE</h1> */}\r\n\r\n      <ul className=\"BookList\">\r\n        {books.map(({ id, imgUrl, title }) => (\r\n          <li key={id}>\r\n            {/* Для того чтобы при клике на книгу перенаправляло на новую страницу с информацией именно о ней. Создаем еще один Link с путем, в котором указываем одно из свойств props->match->url (это свойство показывает буквально то, что находится в адресной строке. И его удобно использовать для создания вложенных маршрутов. Хранит информацию как текущий Route совпал с pathname) и id*/}\r\n            <Link\r\n              to={{\r\n                pathname: `/books/${id}`,\r\n\r\n                // в state можно передавать информацию, откуда ты пришел на эту страницу\r\n                state: { from: location },\r\n              }}\r\n            >\r\n              <BookPreview imgUrl={imgUrl} title={title} />\r\n            </Link>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n    </>\r\n  );\r\n};\r\n\r\n// вызваем функцию withRouter(), где в параметр передаем ссылку на BookList\r\nexport default withRouter(BookList);\r\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","// отрисовывает все authors из db.json\r\n\r\nimport React, { Component } from 'react';\r\n\r\nimport { NavLink, Route } from 'react-router-dom'; //для создания вложенного маршрута, чтобы информация об авторе при клике отрисовывалась на той же странице\r\n\r\nimport axios from 'axios';\r\n\r\n// Components\r\nimport BookList from '../../components/BookList'; // import компонента для отрисовки на одной странице информации о книгах автора\r\n\r\nclass AuthorsPage extends Component {\r\n  state = {\r\n    authors: [],\r\n  };\r\n\r\n  // ЖИЗНЕННЫЕ ЦИКЛЫ\r\n  // при Mount компонента отрисовываются все книги при переходе на страницу BOOKS с помощью async await\r\n  async componentDidMount() {\r\n    const response = await axios.get(\r\n      ' http://localhost:3000/authors?_embed=books',\r\n    );\r\n    // console.log(response.data);\r\n\r\n    this.setState({ authors: response.data });\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        <ul>\r\n          {this.state.authors.map(author => (\r\n            <li key={author.id}>\r\n              {/* для создания вложенного маршрута, чтобы информация об авторе при\r\n              клике отрисовывалась на той же странице оборачиваем в NavLink */}\r\n              <NavLink to={`${this.props.match.url}/${author.id}`}>\r\n                {author.name}\r\n              </NavLink>\r\n            </li>\r\n          ))}\r\n        </ul>\r\n\r\n        {/* для создания вложенного маршрута, чтобы информация об авторе при клике отрисовывалась на той же странице оборачиваем в NavLink. В этом случае  Route создаем на той же странице */}\r\n        <Route\r\n          path={`${this.props.match.path}/:authorId`}\r\n          // component={AuthorBooks}\r\n\r\n          //если component нужно передать доп. props для этого используем render={в который передаем функцию, в который возвращаем наш компонент с доп. props}\r\n          render={props => {\r\n            // console.log(props);\r\n\r\n            // логика поиска книг одного автора\r\n            const bookId = Number(props.match.params.authorId); //выводим id  книги указанного автора\r\n            // console.log(bookId);\r\n\r\n            const authorBooks = this.state.authors.find(\r\n              author => author.id === bookId,\r\n            ); //находим совпадающие id\r\n            // console.log(authorBooks);\r\n            // console.log(authorBooks.books);\r\n\r\n            // чтобы не выдавало ошибку, добавляем условие, если массив authorBooks непустой\r\n            return (\r\n              authorBooks && (\r\n                <>\r\n                  <h2>Книги автора: {authorBooks.name}</h2>\r\n                  <BookList {...props} books={authorBooks.books} />\r\n                </>\r\n              )\r\n            );\r\n            // как было до, без условия\r\n            // return  <AuthorBooks {...props} authors={this.state.authors} />;\r\n          }}\r\n        />\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default AuthorsPage;\r\n"],"sourceRoot":""}